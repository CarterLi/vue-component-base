# VueComponentBase

Due to the design of https://github.com/vuejs/vue-class-component and https://github.com/kaorun343/vue-property-decorator, they have some limitations ( holes ) that you may encounter.

## For vue-class-component, [If you define an arrow function as a class property and access this in it, it will not work.](https://github.com/vuejs/vue-class-component#caveats-of-class-properties)

https://github.com/vuejs/vue-class-component copies all fields (that are not undefined) into a new object: https://github.com/vuejs/vue-class-component/blob/fa148fe3d29cd7a4ccde08a8039383ca99ef1840/src/data.ts#L37

Thus if you use this in arrow functions of class fields, the `this` object still points to the [old class instance that vue-class-component created](https://github.com/vuejs/vue-class-component/blob/fa148fe3d29cd7a4ccde08a8039383ca99ef1840/src/data.ts#L31) instead of the newly copied object.

Copying is mainly for avoiding conflicts between `data()` and `props: {}`. Instead of copying, this repo [deletes fields that declared as props](https://github.com/CarterLi/vue-component-base/blob/975756ec1e1c4f79009b9c10ab5712cbe9c33101/index.ts#L109). The data object used by Vue is still the instance created using `new Class`.

For example, following code should work ( Modified from https://element.eleme.io/#/en-US/component/form ):

```js
@Component()
class MyComponent {
  rules = {
    pass: [
      { validator(rule, value, callback) {
        if (value === '') {
          callback(new Error('Please input the password'));
        } else {
          if (this.ruleForm.checkPass !== '') {
            this.$refs.ruleForm.validateField('checkPass');
          }
          callback();
        }
      }, trigger: 'blur' },
    ],
    checkPass: [
      { validator(rule, value, callback) {
        if (value === '') {
          callback(new Error('Please input the password again'));
        } else if (value !== this.ruleForm.pass) {
          callback(new Error('Two inputs don\'t match!'));
        } else {
          callback();
        }
      }, trigger: 'blur' },
    ],
  };
}
```

## For vue-property-decorator, [It's not supported to define each default property like @Prop() prop = 'default value'](https://github.com/kaorun343/vue-property-decorator#each-props-default-value-need-to-be-defined-as-same-as-the-example-code-shown-in-above)

https://github.com/kaorun343/vue-property-decorator is developed independently from vue-class-component, thus vue-property-decorator cannot touch the class instance created by vue-class-component. For field initialization values, they can only be acquired from created instance, which results the limitation.

This repo has no such limitations. It uses [beforeCreate](https://vuejs.org/v2/api/#beforeCreate) to [update the default value of props on every component creation](https://github.com/CarterLi/vue-component-base/blob/c1b394bd09639298bf2133affc5ab96b466bd547/index.ts#L93).

In addition, it tries to fix the type metadata generated by TypeScript. TS compiler always generates `Object` if an explicit type declaration is used. Following code should now work as expected.

```ts
@Component()
class MyComponent {
  @Prop() p = 123; // Behaves as `props: { type: Number, default: 123 }`
}
```

## Supported decorators and suggested usage

```html
<!-- myComponent/myComponent.vue -->
<template><div ref="div" v-text="computedVar"></div></template>
<!-- Don't write scripts directly in .vue file. Type checks behave very strange in `.vue` file -->
<script src="./myComponent.ts"></script>
```

```ts
// myComponent/myComponent.ts
import { Component, VueComponentBase } from 'vue-component-base';

@Component() // Parens are required
export default class MyComponent extends VueComponentBase { // NOT `extends Vue` because the constructor of Vue does extra works which are not needed in our class
  @Prop() readonly prop = 'default prop'; // https://github.com/kaorun343/vue-property-decorator#Prop

  foo = ''; // Normal property
  arrowFn = () => this.foo = 456; // Arrow function property

  undefinedValue = undefined; // Different from https://github.com/vuejs/vue-class-component#undefined-will-not-be-reactive, this is reactive

  undefinedValue2; // This is NOT reactive, TypeScript won't generate code for fields that have no init value. ( while babel and the standard do )

  @Inreactive // It's not reactive, useful for constant values
  readonly MY_CONSTANT = 'some constants';

  mounted() {} // Lifecycle hook with intellisense

  doSomeAction() {} // Normal method

  @Watch('field') // https://github.com/kaorun343/vue-property-decorator#-watchpath-string-options-watchoptions---decorator
  onFieldChange(val: string, oldVal: string) {}

  @Filter('myFilter')
  myFilter(value: any) {} // Component level custom filter

  get computedVar() { // Computed properties
    return 'field: ' + this.field;
  }
}
```

```ts
// myComponent/index.ts
export { default as MyComponent } from './myComponent'; // Don't write './myComponent.vue'.
// Webpack will still export `myComponent.vue` but TypeScript regards './myComponent' as `myComponent.ts`, thus the component class type works
```

```ts
// Your page component
import { Component, VueComponentBase } from 'vue-component-base';

import { MyComponent } from './myComponent'; // './myComponent/myComponent.vue' with type `import('./myComponent/myComponent.ts').default`

@Component({
  component: {
    MyCompnent,
  },
})
export default class PageComponent extends VueComponentBase {
  @Ref() readonly myComponent: MyComponent; // https://github.com/kaorun343/vue-property-decorator#-refrefkey-string-decorator

  method() {
    this.myComponent.doSomeAction(); // Perfect type checks and intellisense
  }
}
```

## License

MIT
